// gram_CharBlockImpl.lzz
//

#hdr
// gram
#include "gram_BlockImpl.h"
#end

#src
// std lib
#include <cstdlib>
#include <cctype>
#include <cstring>
#end

namespace gram
{
  // CharBlockImpl
  class CharBlockImpl : public BlockImpl
  {
    // characters
    char * m_data;

    // length of data
    int m_length;

    // size allocated
    int m_size;

    // number of lines
    int m_num_lines;

    // initial size
    enum { INITSIZE = 32 }

  public:
    // constructor
    CharBlockImpl (util::Loc const & loc)
      : BlockImpl (loc), m_size (INITSIZE), m_length (0), m_num_lines (0)
    {
      m_data = (char *) malloc (m_size);
      m_data [0] = '\0';
    }

    // destructor
    ~ CharBlockImpl ()
    {
      free (m_data);
    }

    // true if chararacter block
    bool isCharBlock () const
    {
      return true;
    }

    // to string
    util::String toString () const
    {
      return m_data;
    }

    // append
    void append (char ch)
    {
      if (m_length + 1 == m_size)
      {
        m_size *= 2;
        m_data = (char *) realloc (m_data, m_size);
      }
      m_data [m_length] = ch;
      m_data [++ m_length] = '\0';
      if (ch == '\n')
      {
        m_num_lines ++;
      }
    }

    // append
    void append (char const * str)
    {
      for (char const * s = str; * s != '\0'; ++ s)
      {
        append (* s);
      }
    }

    // get c string
    inline const char * c_str () const
    {
      return m_data;
    }

    // get number of lines
    inline int getNumLines () const
    {
      return m_num_lines;
    }

    // get length
    inline int getLength () const
    {
      return m_length;
    }

    // freeze
    void freeze ()
    {
      // free unused memory
      m_size = m_length + 1;
      m_data = (char *) realloc (m_data, m_size);
    }

    // trim string
    void trim ()
    {
      char * s = m_data;
      while (* s && isspace (* s))
      {
        if (* s == '\n')
        {
          -- m_num_lines;
        }
        ++ s;
      }
      if (s != m_data)
      {
        m_length -= s - m_data;
        memmove (m_data, s, m_length);
      }
      s = m_data + m_length - 1;
      while (s >= m_data && isspace (* s))
      {
        if (* s == '\n')
        {
          -- m_num_lines;
        }
        -- s;
      }
      m_length = s + 1 - m_data; 
      * (s + 1) = '\0';
      // free excess memory
      freeze ();
    }

    // true if empty (has only white space characters, if any)
    bool isEmpty () const
    {
      for (char * s = m_data; * s != '\0'; ++ s)
      {
        if (! isspace (* s))
        {
          return false;
        }
      }
      return true;
    }
  }
}
